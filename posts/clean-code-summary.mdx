---
title: Book Summary of Clean Code
subtitle: Wise words from Uncle Bob.
date: '2023-06-17'
---

## Chapter 1: Clean Code

-   Clean code is essential for software development success.
-   Clean code is readable, simple, and focused on a single task.
-   Writing clean code is a professional responsibility.

## Chapter 2: Meaningful Names

-   Names should be meaningful and reveal the intent of the variable, function, or class.
-   Choose descriptive names that are pronounceable and searchable.
-   Avoid using misleading or ambiguous names.

## Chapter 3: Functions

-   Functions should be small, perform a single task, and have a clear purpose.
-   Use descriptive function names and avoid long parameter lists.
-   Aim for functions that fit in your field of view without scrolling.

## Chapter 4: Comments

-   Comments should be used sparingly and only when necessary to clarify complex logic or business rules.
-   Avoid writing comments that state the obvious or duplicate code.
-   Write self-explanatory code instead of relying heavily on comments.

## Chapter 5: Formatting

-   Consistent and readable formatting is crucial for clean code.
-   Follow a consistent style guide and use indentation, spacing, and line length appropriately.
-   Use vertical spacing and empty lines to separate logical blocks of code.

## Chapter 6: Objects and Data Structures

-   Encapsulate data and behavior into objects with well-defined responsibilities.
-   Hide internal data and provide controlled access through methods.
-   Avoid exposing internal details of objects through getters and setters.

## Chapter 7: Error Handling

-   Use exceptions instead of error codes for error handling.
-   Separate error handling code from the main logic for better readability.
-   Do not ignore exceptions or log and swallow them silently.

## Chapter 8: Boundaries

-   Use abstraction to separate external dependencies from the core logic.
-   Create clear interfaces and define adapters for integrating with external systems.
-   Keep external dependencies at the boundaries of the application.

## Chapter 9: Unit Tests

-   Write comprehensive and automated tests for all code.
-   Unit tests should be fast, independent, and cover different scenarios.
-   Test behavior and not implementation details.

## Chapter 10: Classes

-   Classes should have a single responsibility and be small.
-   Follow the Single Responsibility Principle (SRP) to design cohesive and maintainable classes.
-   Avoid God classes that violate the SRP.

## Chapter 11: Systems

-   Modularize large systems into smaller components.
-   Design systems that are composed of well-defined modules with clear responsibilities.
-   Use dependency injection and loose coupling to achieve flexibility and extensibility.

## Chapter 12: Emergence

-   Design code that can evolve and adapt to changing requirements.
-   Embrace emergent design by starting with simple, working solutions and refactoring as needed.
-   Continuously improve code through iteration and feedback.

## Chapter 13: Concurrency

-   Be mindful of concurrency and potential race conditions in multi-threaded environments.
-   Use thread-safe data structures and synchronization mechanisms to ensure correctness.
-   Understand the trade-offs and challenges of concurrent programming.

## Chapter 14: Successive Refinement

-   Code should be continually improved through refactoring.
-   Refactor code by making small, incremental changes to improve its design and clarity.
-   Write tests to ensure the behavior of the code remains unchanged after refactoring.

## Chapter 15: JUnit Internals

-   Understand the internal workings of the JUnit testing framework.
-   Use annotations, assertions, and test runners effectively.
-   Write tests that are independent, isolated, and maintainable.

## Chapter 16: Refactoring SerialDate

-   A case study of refactoring an existing codebase.
-   Applying various principles and techniques to transform complex and poorly designed code into clean code.
